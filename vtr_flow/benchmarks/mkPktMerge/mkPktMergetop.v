// Created by Verilog::EditFiles from mkPktMerge.v
// Created by Verilog::EditFiles from mkPktMerge.v
//
// Generated by Bluespec Compiler, version 2009.11.beta2 (build 18693, 2009-11-24)
//
// On Tue Jun  8 18:41:53 EDT 2010
//
//
// Ports:
// Name                         I/O  size props
// RDY_iport0_put                 O     1
// RDY_iport1_put                 O     1
// oport_get                      O   153
// RDY_oport_get                  O     1
// CLK                            I     1 clock
// RST_N                          I     1 reset
// iport0_put                     I   153
// iport1_put                     I   153
// EN_iport0_put                  I     1
// EN_iport1_put                  I     1
// EN_oport_get                   I     1
//
// No combinational paths from inputs to outputs
//
//



module mkPktMerge(CLK,
		  RST_N,

		//  iport0_put,
		  EN_iport0_put,
		  RDY_iport0_put,

		//  iport1_put,
		  EN_iport1_put,
		  RDY_iport1_put,

		  EN_oport_get,
		//  oport_get,
		  RDY_oport_get,
		  
		  //fbmao add
		 // fi0__D_IN,
		  //fi0__ENQ,
		  fi0__DEQ,
		//  fi0__CLR,
		  fi0__D_OUT,
		  fi0__EMPTY_N,
		  fi0__FULL_N,
		///  fi1__D_IN,
		//  fi1__ENQ,
		  fi1__DEQ,
		//  fi1__CLR,
		  fi1__D_OUT,
		  fi1__EMPTY_N,
		  fi1__FULL_N,
		  fo__D_IN,
		  fo__ENQ,
		  fo__EMPTY_N,
		  fo__FULL_N	  
		  
		  );
  input  CLK;
  input  RST_N;

  // action method iport0_put
  //input  [152 : 0] iport0_put;
  input  EN_iport0_put;
  output RDY_iport0_put;

  // action method iport1_put
 // input  [152 : 0] iport1_put;
  input  EN_iport1_put;
  output RDY_iport1_put;

  // actionvalue method oport_get
  input  EN_oport_get;
  //output [152 : 0] oport_get;
  output RDY_oport_get;

  // signals for module outputs
 // wire [152 : 0] oport_get;
  wire RDY_iport0_put, RDY_iport1_put, RDY_oport_get;

  // register fi0Active
  reg fi0Active;
  wire fi0Active__D_IN;
	wire fi0Active__EN;

  // register fi0HasPrio
  reg fi0HasPrio;
  reg fi0HasPrio__D_IN;
  wire fi0HasPrio__EN;

  // register fi1Active
  reg fi1Active;
  wire fi1Active__D_IN, fi1Active__EN;

  // ports of submodule fi0
 // output [152 : 0] fi0__D_IN; 
  input [152 : 0] fi0__D_OUT;
  
//  wire [152 : 0] fi0__D_IN;
  wire [152 : 0] fi0__D_OUT;
  
  output fi0__DEQ;   //// fi0__CLR;  /// fi0__ENQ;
  input fi0__EMPTY_N, fi0__FULL_N;
  wire fi0__DEQ, fi0__EMPTY_N, fi0__FULL_N; // fi0__CLR, fi0__ENQ,

  // ports of submodule fi1
  ///output [152 : 0] fi1__D_IN;
  input [152 : 0] fi1__D_OUT;
  wire [152 : 0]  fi1__D_OUT;  ///fi1__D_IN,
  
  output fi1__DEQ;  ///fi1__CLR;   ////fi1__ENQ 
  input fi1__EMPTY_N, fi1__FULL_N;
  wire  fi1__DEQ, fi1__EMPTY_N,  fi1__FULL_N; ///fi1__ENQ,  fi1__CLR,

  // ports of submodule fo
  output [152 : 0] fo__D_IN;
  reg [152 : 0] fo__D_IN;
  //wire [152 : 0] fo__D_OUT;
  
  output fo__ENQ;    //, fo__DEQ;
  input fo__EMPTY_N, fo__FULL_N;
  wire  fo__EMPTY_N, fo__ENQ, fo__FULL_N;  //fo__DEQ,fo__CLR,

  // rule scheduling signals
  wire CAN_FIRE_RL_arbitrate,
       CAN_FIRE_RL_fi0_advance,
       CAN_FIRE_RL_fi1_advance,
       CAN_FIRE_iport0_put,
       CAN_FIRE_iport1_put,
       CAN_FIRE_oport_get,
       WILL_FIRE_RL_arbitrate,
       WILL_FIRE_RL_fi0_advance,
       WILL_FIRE_RL_fi1_advance,
       WILL_FIRE_iport0_put,
       WILL_FIRE_iport1_put,
       WILL_FIRE_oport_get;

  // inputs to muxes for submodule ports
  wire [152 : 0] MUX_fo__enq_1__VAL_1;
  wire MUX_fi0Active__write_1__SEL_1,
       MUX_fi0Active__write_1__VAL_1,
       MUX_fi1Active__write_1__SEL_1;

  // remaining internal signals
  reg [63 : 0] v__h679;
  wire fo_RDY_enq_AND_IF_fi0HasPrio_THEN_fi0_RDY_firs_ETC___d10;

  // action method iport0_put
  assign RDY_iport0_put = fi0__FULL_N ;
  assign CAN_FIRE_iport0_put = fi0__FULL_N ;
  assign WILL_FIRE_iport0_put = EN_iport0_put ;

  // action method iport1_put
  assign RDY_iport1_put = fi1__FULL_N ;
  assign CAN_FIRE_iport1_put = fi1__FULL_N ;
  assign WILL_FIRE_iport1_put = EN_iport1_put ;

  // actionvalue method oport_get
  //assign oport_get = fo__D_OUT ;
  assign RDY_oport_get = fo__EMPTY_N ;
  assign CAN_FIRE_oport_get = fo__EMPTY_N ;
  assign WILL_FIRE_oport_get = EN_oport_get ;

  // // submodule fi0
  // arSRLFIFO_a fi0						(.CLK(CLK),
								    // .RST_N(RST_N),
								    // .D_IN(fi0__D_IN),
								    // .ENQ(fi0__ENQ),
								    // .DEQ(fi0__DEQ),
								    // .CLR(fi0__CLR),
								    // .D_OUT(fi0__D_OUT),
								    // .EMPTY_N(fi0__EMPTY_N),
								    // .FULL_N(fi0__FULL_N));

  // // submodule fi1
  // arSRLFIFO_b fi1
									// (.CLK(CLK),
								    // .RST_N(RST_N),
								    // .D_IN(fi1__D_IN),
								    // .ENQ(fi1__ENQ),
								    // .DEQ(fi1__DEQ),
								    // .CLR(fi1__CLR),
								    // .D_OUT(fi1__D_OUT),
								    // .EMPTY_N(fi1__EMPTY_N),
								    // .FULL_N(fi1__FULL_N));

  // // submodule fo
  // arSRLFIFO_c fo
									// (.CLK(CLK),
								   // .RST_N(RST_N),
								   // .D_IN(fo__D_IN),
								   // .ENQ(fo__ENQ),
								   // .DEQ(fo__DEQ),
								   // .CLR(fo__CLR),
								   // .D_OUT(fo__D_OUT),
								   // .EMPTY_N(fo__EMPTY_N),
								   // .FULL_N(fo__FULL_N));

  // rule RL_arbitrate
  assign CAN_FIRE_RL_arbitrate =
	     fo_RDY_enq_AND_IF_fi0HasPrio_THEN_fi0_RDY_firs_ETC___d10 &&
	     fi0__EMPTY_N &&
	     fi1__EMPTY_N &&
	     !fi0Active &&
	     !fi1Active ;
  assign WILL_FIRE_RL_arbitrate = CAN_FIRE_RL_arbitrate ;

  // rule RL_fi0_advance
  assign CAN_FIRE_RL_fi0_advance = fi0__EMPTY_N && fo__FULL_N && !fi1Active ;
  assign WILL_FIRE_RL_fi0_advance =
	     CAN_FIRE_RL_fi0_advance && !WILL_FIRE_RL_arbitrate ;

  // rule RL_fi1_advance
  assign CAN_FIRE_RL_fi1_advance = fi1__EMPTY_N && fo__FULL_N && !fi0Active ;
  assign WILL_FIRE_RL_fi1_advance =
	     CAN_FIRE_RL_fi1_advance && !WILL_FIRE_RL_fi0_advance &&
	     !WILL_FIRE_RL_arbitrate ;

  // inputs to muxes for submodule ports
  assign MUX_fi0Active__write_1__SEL_1 = WILL_FIRE_RL_arbitrate && fi0HasPrio ;
  assign MUX_fi1Active__write_1__SEL_1 =
	     WILL_FIRE_RL_arbitrate && !fi0HasPrio ;
  assign MUX_fi0Active__write_1__VAL_1 =
	     fi0HasPrio ? !fi0__D_OUT[151] : !fi1__D_OUT[151] ;
  assign MUX_fo__enq_1__VAL_1 = fi0HasPrio ? fi0__D_OUT : fi1__D_OUT ;

  // register fi0Active
  assign fi0Active__D_IN =
	     MUX_fi0Active__write_1__SEL_1 ?
	       MUX_fi0Active__write_1__VAL_1 :
	       !fi0__D_OUT[151] ;
  assign fi0Active__EN =
	     WILL_FIRE_RL_arbitrate && fi0HasPrio ||
	     WILL_FIRE_RL_fi0_advance ;

  // register fi0HasPrio
  always@(WILL_FIRE_RL_arbitrate or
	  fi0HasPrio or WILL_FIRE_RL_fi0_advance or WILL_FIRE_RL_fi1_advance)
  begin
   // case (1'b1) // synopsys parallel_case
     // WILL_FIRE_RL_arbitrate: fi0HasPrio__D_IN = !fi0HasPrio;
    //  WILL_FIRE_RL_fi0_advance: fi0HasPrio__D_IN = 1'd0;
    //  WILL_FIRE_RL_fi1_advance: fi0HasPrio__D_IN = 1'd1;
    //case (1'b1) // synopsys parallel_case
    //  WILL_FIRE_RL_arbitrate: fi0HasPrio__D_IN = !fi0HasPrio;
	 fi0HasPrio__D_IN = !fi0HasPrio;
   //   WILL_FIRE_RL_fi0_advance: fi0HasPrio__D_IN = 1'd0;
    //  WILL_FIRE_RL_fi1_advance: fi0HasPrio__D_IN = 1'd1;

//    endcase
    //endcase
  end
  assign fi0HasPrio__EN =
	     WILL_FIRE_RL_arbitrate || WILL_FIRE_RL_fi0_advance ||
	     WILL_FIRE_RL_fi1_advance ;

  // register fi1Active
  assign fi1Active__D_IN =
	     MUX_fi1Active__write_1__SEL_1 ?
	       MUX_fi0Active__write_1__VAL_1 :
	       !fi1__D_OUT[151] ;
  assign fi1Active__EN =
	     WILL_FIRE_RL_arbitrate && !fi0HasPrio ||
	     WILL_FIRE_RL_fi1_advance ;

  // submodule fi0
//  assign fi0__D_IN = iport0_put ;
  assign fi0__DEQ =
	     WILL_FIRE_RL_arbitrate && fi0HasPrio ||
	     WILL_FIRE_RL_fi0_advance ;
 // assign fi0__ENQ = EN_iport0_put ;
//  assign fi0__CLR = 1'b0 ;

  // submodule fi1
  //assign fi1__D_IN = iport1_put ;
  assign fi1__DEQ =
	     WILL_FIRE_RL_arbitrate && !fi0HasPrio ||
	     WILL_FIRE_RL_fi1_advance ;
 /// assign fi1__ENQ = EN_iport1_put ;
 // assign fi1__CLR = 1'b0 ;

  // submodule fo
  always@(WILL_FIRE_RL_arbitrate or
	  MUX_fo__enq_1__VAL_1 or
	  WILL_FIRE_RL_fi0_advance or
	  fi0__D_OUT or WILL_FIRE_RL_fi1_advance or fi1__D_OUT)
  begin
   // case (1'b1) // synopsys parallel_case
      //WILL_FIRE_RL_arbitrate: fo__D_IN = MUX_fo__enq_1__VAL_1;
	  fo__D_IN = MUX_fo__enq_1__VAL_1;
    //  WILL_FIRE_RL_fi0_advance: fo__D_IN = fi0__D_OUT;
    //  WILL_FIRE_RL_fi1_advance: fo__D_IN = fi1__D_OUT;

   // endcase
  end
 // assign fo__DEQ = EN_oport_get ;
  assign fo__ENQ =
	     WILL_FIRE_RL_arbitrate || WILL_FIRE_RL_fi0_advance ||
	     WILL_FIRE_RL_fi1_advance ;
 // assign fo__CLR = 1'b0 ;

  // remaining internal signals
  assign fo_RDY_enq_AND_IF_fi0HasPrio_THEN_fi0_RDY_firs_ETC___d10 =
	     fo__FULL_N && (fi0HasPrio ? fi0__EMPTY_N : fi1__EMPTY_N) ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (!RST_N)
      begin
        fi0Active <= 1'd0;
	fi0HasPrio <=  1'd1;
	fi1Active <=  1'd0;
      end
    else
      begin
        if (fi0Active__EN) fi0Active <= fi0Active__D_IN;
	if (fi0HasPrio__EN)
	  fi0HasPrio <=  fi0HasPrio__D_IN;
	if (fi1Active__EN) fi1Active <=  fi1Active__D_IN;
      end
  end


  // handling of system tasks


endmodule  // mkPktMerge

